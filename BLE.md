# BlueGate BLE Protocol Documentation

This document describes the Bluetooth Low Energy (BLE) protocol for BlueGate access control devices. It is intended for iOS and Android client developers.

## Device Information

- **Device Name**: Configurable (default: "BlueGate")
- **Appearance**: Access Control - Entrance Gate (0x0C41)
- **Advertising**: Connectable, Scannable, Undirected
- **Advertised Service UUID**: `6a7e6a7e-4929-42d0-0000-fcc5a35e13f1` (Gate Service)

## Gate Service

**Service UUID**: `6a7e6a7e-4929-42d0-0000-fcc5a35e13f1`

All characteristic UUIDs below are short forms (16-bit). The full 128-bit UUID is constructed using the Bluetooth Base UUID:
`0000XXXX-0000-1000-8000-00805F9B34FB` where `XXXX` is the short UUID.

For example, characteristic `0x0100` has the full UUID: `00000100-0000-1000-8000-00805F9B34FB`

---

## Authentication Characteristics

### Nonce (0x0100)
| Property | Value |
|----------|-------|
| UUID | 0x0100 |
| Size | 32 bytes |
| Properties | Read |
| Description | Server-generated random nonce for authentication challenge |

The server generates a new random nonce on each connection. Read this value as part of the authentication flow.

---

### Authenticate (0x0101)
| Property | Value |
|----------|-------|
| UUID | 0x0101 |
| Size | 64 bytes |
| Properties | Write |
| Description | Digital signature for authentication |

Write a 64-byte signature to complete authentication. The signature must be computed over the digest:
```
digest = SHA256(server_nonce || client_nonce)
```

**Supported signature algorithms:**
- **Ed25519**: 64-byte signature
- **ECDSA secp256r1**: 64-byte raw signature (r || s), NOT DER encoded

---

### Client Public Key (0x0102)
| Property | Value |
|----------|-------|
| UUID | 0x0102 |
| Size | 32 or 33 bytes |
| Properties | Read, Write |
| Description | Client's public key for authorization |

Write the client's public key to authorize the session. The device will look up this key in its authorized keys database.

**Key formats:**
- **Ed25519**: 32 bytes (raw public key)
- **secp256r1**: 33 bytes (compressed SEC1 format: 0x02/0x03 prefix + 32-byte X coordinate)

After writing, read `client_key_ack` to check if the key was recognized.

---

### Client Nonce (0x0103)
| Property | Value |
|----------|-------|
| UUID | 0x0103 |
| Size | 32 bytes |
| Properties | Write |
| Description | Client-generated random nonce |

Write a 32-byte random nonce generated by the client. This nonce is combined with the server nonce to create the authentication challenge.

---

### Client Key Acknowledgement (0x0104)
| Property | Value |
|----------|-------|
| UUID | 0x0104 |
| Size | 1 byte (boolean) |
| Properties | Read, Notify |
| Description | Indicates if client's public key was found in authorized keys |

**Values:**
- `0x00` (false): Key not recognized
- `0x01` (true): Key recognized and authorized

Subscribe to notifications to receive updates after writing `client_pubkey`.

---

### Authenticate Acknowledgement (0x0105)
| Property | Value |
|----------|-------|
| UUID | 0x0105 |
| Size | 1 byte (boolean) |
| Properties | Read, Notify |
| Description | Indicates if authentication was successful |

**Values:**
- `0x00` (false): Authentication failed
- `0x01` (true): Authentication successful, gate will open

Subscribe to notifications to receive the authentication result after writing to `authenticate`.

---

### Action (0x0106)
| Property | Value |
|----------|-------|
| UUID | 0x0106 |
| Size | 2 bytes (uint16) |
| Properties | Read, Write |
| Description | Reserved for future gate actions |

Currently unused. Reserved for future functionality.

---

### Payload (0x0107)
| Property | Value |
|----------|-------|
| UUID | 0x0107 |
| Size | 33 bytes |
| Properties | Write |
| Description | Reserved for future use |

Currently unused. Reserved for future functionality.

---

### Permissions (0x0108)
| Property | Value |
|----------|-------|
| UUID | 0x0108 |
| Size | 1 byte |
| Properties | Read |
| Description | User's permission level after key authorization |

Returns the permission byte for the authorized key (with 2 LSB bits masked out):

**Permission bits (6 MSB):**
| Bit | Value | Description |
|-----|-------|-------------|
| 7 | 0x80 | Admin permission |
| 6 | 0x40 | Reserved |
| 5 | 0x20 | Reserved |
| 4 | 0x10 | Reserved |
| 3 | 0x08 | Reserved |
| 2 | 0x04 | Reserved |

---

## Management Characteristics (Admin Only)

These characteristics are only functional for users with admin permission (bit 7 set, i.e., `perm & 0x80 == 0x80`).

### Management Action (0x1100)
| Property | Value |
|----------|-------|
| UUID | 0x1100 |
| Size | 1 byte |
| Properties | Write |
| Description | Trigger a management action |

Write an action code to execute the corresponding management operation. Parameters must be set in the appropriate characteristics before triggering.

**Action Codes:**
| Code | Description | Required Parameters |
|------|-------------|---------------------|
| 0x01 | Add key | `management_key` |
| 0x02 | Delete key | `management_key` |
| 0x03 | Get key by index | `management_param_val` (index as u32 LE; result in `management_key`, count in `management_param_val`) |
| 0x10 | Set config parameter | `management_param_id`, `management_param_val` |
| 0x11 | Get config parameter | `management_param_id` (result in `management_param_val`) |
| 0x20 | Set device name | `management_name` |

---

### Management Key (0x1101)
| Property | Value |
|----------|-------|
| UUID | 0x1101 |
| Size | 33 bytes |
| Properties | Read, Write |
| Description | Key data for add/delete/get operations |

**Key format (33 bytes):**
```
Byte 0: Flags/Permissions byte
  - Bits 0-1: Key type (0x01 = Ed25519, 0x02/0x03 = secp256r1 compressed point sign)
  - Bits 2-7: Permissions (bit 7 = admin)
  
Bytes 1-32: Public key data
  - Ed25519: 32-byte raw public key
  - secp256r1: 32-byte X coordinate
```

**Examples:**
- Ed25519 admin key: `[0x81, <32 bytes pubkey>]` (0x81 = admin + Ed25519)
- Ed25519 regular key: `[0x01, <32 bytes pubkey>]`
- secp256r1 admin key: `[0x82, <32 bytes X>]` or `[0x83, <32 bytes X>]`

For deletion, only the 2 LSB bits of byte 0 and bytes 1-32 are compared.

---

### Management Parameter ID (0x1102)
| Property | Value |
|----------|-------|
| UUID | 0x1102 |
| Size | 1 byte |
| Properties | Write |
| Description | Configuration slot ID for parameter operations |

**Defined Configuration Slots:**
| Slot | Name | Description |
|------|------|-------------|
| 0 | OpenDuration | Gate open duration (ms) |
| 1 | CloseDelay | Delay before auto-close (ms) |
| 2 | LampDuration | Lamp on duration (ms) |
| 3 | AdvInterval | BLE advertising interval (ms) |
| 4 | ObstacleTimeout | Obstacle detection timeout (ms) |
| 5-254 | Reserved | Available for future use |
| 255 | Reserved | Used internally for device name |

---

### Management Parameter Value (0x1103)
| Property | Value |
|----------|-------|
| UUID | 0x1103 |
| Size | 4 bytes (uint32, little-endian) |
| Properties | Read, Write |
| Description | Value for configuration parameter (write for set, read after get) |

---

### Management Name (0x1104)
| Property | Value |
|----------|-------|
| UUID | 0x1104 |
| Size | 64 bytes |
| Properties | Read, Write |
| Description | Device name (null-terminated UTF-8) |

On connection, this characteristic is populated with the current device name. Read to get the current name; write to set a new name (requires admin). Maximum 63 characters plus null terminator. The name change takes effect after device restart.

---

### Management Result (0x1105)
| Property | Value |
|----------|-------|
| UUID | 0x1105 |
| Size | 1 byte |
| Properties | Read, Notify |
| Description | Result of the last management operation |

**Result Codes:**
| Code | Name | Description |
|------|------|-------------|
| 0x00 | OK | Operation successful |
| 0x01 | NOT_ADMIN | User does not have admin permission |
| 0x02 | FLASH_ERROR | Flash storage error |
| 0x03 | NOT_FOUND | Key not found (for deletion) |
| 0x04 | INVALID | Invalid operation (key exists, store full, unknown action) |

Subscribe to notifications to receive the result after triggering a management action.

---

## Authentication Flow

### Step 1: Connect and Discover Services
1. Scan for devices advertising the Gate Service UUID
2. Connect to the device
3. Discover the Gate Service and its characteristics

### Step 2: Authorize Public Key
1. Read `nonce` (0x0100) - save the 32-byte server nonce
2. Write your public key to `client_pubkey` (0x0102)
   - Ed25519: 32 bytes
   - secp256r1: 33 bytes (compressed)
3. Read or wait for notification on `client_key_ack` (0x0104)
   - If `false`: Key not authorized, authentication will fail
   - If `true`: Key recognized, proceed to authentication

### Step 3: Authenticate
1. Generate a 32-byte random `client_nonce`
2. Write `client_nonce` to characteristic 0x0103
3. Compute the digest: `SHA256(server_nonce || client_nonce)`
4. Sign the digest with your private key:
   - Ed25519: Standard Ed25519 signature (64 bytes)
   - secp256r1: ECDSA signature in raw format (r || s, 64 bytes)
5. Write the 64-byte signature to `authenticate` (0x0101)
6. Read or wait for notification on `authenticate_ack` (0x0105)
   - If `true`: Gate will open
   - If `false`: Authentication failed

### Pseudocode Example (Ed25519)
```
// Connect and discover services
connection = connect(device)
service = discover_service(GATE_SERVICE_UUID)

// Get server nonce
server_nonce = read(service, 0x0100)  // 32 bytes

// Write public key
write(service, 0x0102, my_ed25519_public_key)  // 32 bytes

// Check if key is recognized
key_ack = read(service, 0x0104)
if (!key_ack) {
    error("Key not authorized")
    return
}

// Generate client nonce
client_nonce = random_bytes(32)
write(service, 0x0103, client_nonce)

// Compute challenge and sign
digest = SHA256(server_nonce + client_nonce)
signature = ed25519_sign(my_private_key, digest)

// Authenticate
write(service, 0x0101, signature)  // 64 bytes

// Check result
auth_ack = read(service, 0x0105)
if (auth_ack) {
    success("Gate opened!")
} else {
    error("Authentication failed")
}
```

---

## Management Flow (Admin Only)

### Adding a New Key
```
// Ensure you are authenticated as admin
if ((read(service, 0x0108) & 0x80) == 0) {
    error("Not admin")
    return
}

// Prepare key data: [permissions | key_type, 32-byte pubkey]
// Example: Regular user with Ed25519 key
key_data = [0x01] + user_public_key  // 33 bytes total

// Write key and trigger add
write(service, 0x1101, key_data)
write(service, 0x1100, 0x01)  // MGMT_ADD_KEY

// Check result
result = read(service, 0x1105)
if (result == 0x00) {
    success("Key added")
}
```

### Deleting a Key
```
// Write key to delete (only type bits and pubkey matter)
write(service, 0x1101, key_data)
write(service, 0x1100, 0x02)  // MGMT_DEL_KEY

result = read(service, 0x1105)
```

### Getting All Keys
```
// Iterate through all stored keys
index = 0
while true:
    // Write index as u32 little-endian to param_val
    write(service, 0x1103, index as u32 LE)  // 4 bytes
    write(service, 0x1100, 0x03)             // MGMT_GET_KEY
    
    result = read(service, 0x1105)
    if result != OK:
        break  // No more keys (NOT_FOUND) or error
    
    key = read(service, 0x1101)              // 33-byte key data
    count = read(service, 0x1103) as u32 LE  // Total key count
    
    process(key)
    index += 1
    if index >= count:
        break
```

### Setting a Configuration Parameter
```
// Set gate open duration to 5000ms
write(service, 0x1102, 0x00)        // Slot 0 = OpenDuration
write(service, 0x1103, 5000)        // Value in ms (little-endian uint32)
write(service, 0x1100, 0x10)        // MGMT_SET_PARAM

result = read(service, 0x1105)
```

### Getting a Configuration Parameter
```
// Get gate open duration
write(service, 0x1102, 0x00)        // Slot 0 = OpenDuration
write(service, 0x1100, 0x11)        // MGMT_GET_PARAM

result = read(service, 0x1105)
if (result == 0x00) {
    value = read(service, 0x1103)   // Read value (little-endian uint32)
}
```

### Setting Device Name
```
// Set device name (null-terminated string, max 63 chars)
name = "My Gate\0" + padding_zeros  // Pad to 64 bytes
write(service, 0x1104, name)
write(service, 0x1100, 0x20)  // MGMT_SET_NAME

result = read(service, 0x1105)
// Name takes effect after device restart
```

---

## Key Storage Format

Keys are stored as 33-byte arrays:

```
Byte 0: Flags byte
  ┌─────────────────────────────────────────┐
  │ Bit 7 │ Bit 6-2  │ Bit 1 │ Bit 0       │
  │ Admin │ Reserved │ Key type (2 bits)   │
  └─────────────────────────────────────────┘
  
  Key types:
  - 0x01: Ed25519
  - 0x02: secp256r1 (even Y)
  - 0x03: secp256r1 (odd Y)

Bytes 1-32: Public key material
  - Ed25519: 32-byte public key
  - secp256r1: 32-byte X coordinate
```

---

## Error Handling

### Connection Issues
- Device may disconnect after authentication timeout
- Reconnect and restart the authentication flow

### Authentication Failures
- Verify the key is registered on the device
- Ensure correct signature algorithm is used
- Check that nonces are fresh (not reused)

### Management Errors
- Always check `management_result` after operations
- Handle flash errors gracefully (retry may help)
- Verify admin status before management operations

---

## Platform-Specific Notes

### iOS (CoreBluetooth)
- Use `CBCharacteristicWriteType.withResponse` for all writes
- Subscribe to notifications using `setNotifyValue(true, for:)`
- Handle `centralManager(_:didDisconnectPeripheral:error:)` for reconnection

### Android (BluetoothGatt)
- Use `BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT` for writes
- Enable notifications via descriptor write (CCCD)
- Request MTU of at least 69 bytes for 64-byte signature writes

---

## Security Considerations

1. **Key Generation**: Generate keys using cryptographically secure random number generators
2. **Key Storage**: Store private keys securely (Keychain on iOS, Keystore on Android)
3. **Nonce Handling**: Never reuse nonces; always generate fresh random values
4. **Connection Security**: Consider using BLE bonding for additional security
5. **Admin Keys**: Protect admin keys carefully; they can add/remove other keys
